"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.GrpcPlugin = exports.GRPC_TRACE_KEY = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const core_1 = require("@opentelemetry/core");
const path = require("path");
const shimmer = require("shimmer");
const utils_1 = require("./utils");
const version_1 = require("./version");
/** The metadata key under which span context is stored as a binary value. */
exports.GRPC_TRACE_KEY = 'grpc-trace-bin';
let grpcClientModule;
class GrpcPlugin extends core_1.BasePlugin {
    constructor(moduleName, version) {
        super('@opentelemetry/plugin-grpc', version_1.VERSION);
        this.moduleName = moduleName;
        this.version = version;
        this.supportedVersions = ['1.*'];
        this._internalFilesList = {
            '0.13 - 1.6': { client: 'src/node/src/client.js' },
            '^1.7': { client: 'src/client.js' },
        };
        this._basedir = basedir;
        this._config = {};
    }
    patch() {
        this._logger.debug('applying patch to %s@%s', this.moduleName, this.version);
        if (this._moduleExports.Server) {
            shimmer.wrap(this._moduleExports.Server.prototype, 'register', this._patchServer());
        }
        // Wrap the externally exported client constructor
        shimmer.wrap(this._moduleExports, 'makeGenericClientConstructor', this._patchClient());
        if (this._internalFilesExports['client']) {
            grpcClientModule = this._internalFilesExports['client'];
            // Wrap the internally used client constructor
            shimmer.wrap(grpcClientModule, 'makeClientConstructor', this._patchClient());
        }
        return this._moduleExports;
    }
    unpatch() {
        this._logger.debug('removing patch to %s@%s', this.moduleName, this.version);
        if (this._moduleExports.Server) {
            shimmer.unwrap(this._moduleExports.Server.prototype, 'register');
        }
        shimmer.unwrap(this._moduleExports, 'makeGenericClientConstructor');
        if (grpcClientModule) {
            shimmer.unwrap(grpcClientModule, 'makeClientConstructor');
        }
    }
    _setSpanContext(metadata) {
        api_1.propagation.inject(metadata, (metadata, k, v) => metadata.set(k, v));
    }
    _patchServer() {
        return (originalRegister) => {
            const plugin = this;
            plugin._logger.debug('patched gRPC server');
            return function register(name, handler, serialize, deserialize, type) {
                const originalResult = originalRegister.apply(this, arguments);
                const handlerSet = this.handlers[name];
                shimmer.wrap(handlerSet, 'func', (originalFunc) => {
                    return function func(call, callback) {
                        const self = this;
                        if (plugin._shouldNotTraceServerCall(call, name)) {
                            switch (type) {
                                case 'unary':
                                case 'client_stream':
                                    return originalFunc.call(self, call, callback);
                                case 'server_stream':
                                case 'bidi':
                                    return originalFunc.call(self, call);
                                default:
                                    return originalResult;
                            }
                        }
                        const spanName = `grpc.${name.replace('/', '')}`;
                        const spanOptions = {
                            kind: api_1.SpanKind.SERVER,
                        };
                        plugin._logger.debug('patch func: %s', JSON.stringify(spanOptions));
                        api_1.context.with(api_1.propagation.extract(call.metadata, (carrier, key) => carrier.get(key)), () => {
                            const span = plugin._tracer
                                .startSpan(spanName, spanOptions)
                                .setAttributes({
                                [semantic_conventions_1.RpcAttribute.GRPC_KIND]: spanOptions.kind,
                            });
                            plugin._tracer.withSpan(span, () => {
                                switch (type) {
                                    case 'unary':
                                    case 'client_stream':
                                        return plugin._clientStreamAndUnaryHandler(plugin, span, call, callback, originalFunc, self);
                                    case 'server_stream':
                                    case 'bidi':
                                        return plugin._serverStreamAndBidiHandler(plugin, span, call, originalFunc, self);
                                    default:
                                        break;
                                }
                            });
                        });
                    };
                });
                return originalResult;
            };
        };
    }
    /**
     * Returns true if the server call should not be traced.
     */
    _shouldNotTraceServerCall(call, name) {
        const parsedName = name.split('/');
        return (utils_1._containsOtelMetadata(call.metadata) ||
            utils_1._methodIsIgnored(parsedName[parsedName.length - 1] || name, this._config.ignoreGrpcMethods));
    }
    _clientStreamAndUnaryHandler(plugin, span, call, callback, original, self) {
        function patchedCallback(err, value, trailer, flags) {
            if (err) {
                if (err.code) {
                    span.setStatus({
                        code: utils_1._grpcStatusCodeToCanonicalCode(err.code),
                        message: err.message,
                    });
                    span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, err.code.toString());
                }
                span.setAttributes({
                    [semantic_conventions_1.RpcAttribute.GRPC_ERROR_NAME]: err.name,
                    [semantic_conventions_1.RpcAttribute.GRPC_ERROR_MESSAGE]: err.message,
                });
            }
            else {
                span.setStatus({ code: api_1.CanonicalCode.OK });
                span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, plugin._moduleExports.status.OK.toString());
            }
            span.addEvent('received');
            // end the span
            span.end();
            return callback(err, value, trailer, flags);
        }
        plugin._tracer.bind(call);
        return original.call(self, call, patchedCallback);
    }
    _serverStreamAndBidiHandler(plugin, span, call, original, self) {
        let spanEnded = false;
        const endSpan = () => {
            if (!spanEnded) {
                spanEnded = true;
                span.end();
            }
        };
        plugin._tracer.bind(call);
        call.on('finish', () => {
            span.setStatus(utils_1._grpcStatusCodeToSpanStatus(call.status.code));
            span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, call.status.code.toString());
            // if there is an error, span will be ended on error event, otherwise end it here
            if (call.status.code === 0) {
                span.addEvent('finished');
                endSpan();
            }
        });
        call.on('error', (err) => {
            span.setStatus({
                code: utils_1._grpcStatusCodeToCanonicalCode(err.code),
                message: err.message,
            });
            span.addEvent('finished with error');
            span.setAttributes({
                [semantic_conventions_1.RpcAttribute.GRPC_ERROR_NAME]: err.name,
                [semantic_conventions_1.RpcAttribute.GRPC_ERROR_MESSAGE]: err.message,
            });
            endSpan();
        });
        return original.call(self, call);
    }
    _patchClient() {
        const plugin = this;
        return (original) => {
            plugin._logger.debug('patching client');
            return function makeClientConstructor(methods, serviceName, options) {
                const client = original.apply(this, arguments);
                shimmer.massWrap(client.prototype, plugin._getMethodsToWrap(client, methods), plugin._getPatchedClientMethods());
                return client;
            };
        };
    }
    _getMethodsToWrap(client, methods) {
        const methodList = [];
        // For a method defined in .proto as "UnaryMethod"
        Object.entries(methods).forEach(([name, { originalName }]) => {
            if (!utils_1._methodIsIgnored(name, this._config.ignoreGrpcMethods)) {
                methodList.push(name); // adds camel case method name: "unaryMethod"
                if (originalName &&
                    // eslint-disable-next-line no-prototype-builtins
                    client.prototype.hasOwnProperty(originalName) &&
                    name !== originalName // do not add duplicates
                ) {
                    // adds original method name: "UnaryMethod",
                    methodList.push(originalName);
                }
            }
        });
        return methodList;
    }
    _getPatchedClientMethods() {
        const plugin = this;
        return (original) => {
            plugin._logger.debug('patch all client methods');
            return function clientMethodTrace() {
                const name = `grpc.${original.path.replace('/', '')}`;
                const args = Array.prototype.slice.call(arguments);
                const metadata = plugin._getMetadata(original, args);
                if (utils_1._containsOtelMetadata(metadata)) {
                    return original.apply(this, args);
                }
                const span = plugin._tracer.startSpan(name, {
                    kind: api_1.SpanKind.CLIENT,
                });
                return plugin._tracer.withSpan(span, () => plugin._makeGrpcClientRemoteCall(original, args, metadata, this, plugin)(span));
            };
        };
    }
    /**
     * This method handles the client remote call
     */
    _makeGrpcClientRemoteCall(original, args, metadata, self, plugin) {
        /**
         * Patches a callback so that the current span for this trace is also ended
         * when the callback is invoked.
         */
        function patchedCallback(span, callback, metadata) {
            const wrappedFn = (err, res) => {
                if (err) {
                    if (err.code) {
                        span.setStatus(utils_1._grpcStatusCodeToSpanStatus(err.code));
                        span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, err.code.toString());
                    }
                    span.setAttributes({
                        [semantic_conventions_1.RpcAttribute.GRPC_ERROR_NAME]: err.name,
                        [semantic_conventions_1.RpcAttribute.GRPC_ERROR_MESSAGE]: err.message,
                    });
                }
                else {
                    span.setStatus({ code: api_1.CanonicalCode.OK });
                    span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, plugin._moduleExports.status.OK.toString());
                }
                span.end();
                callback(err, res);
            };
            return plugin._tracer.bind(wrappedFn);
        }
        return (span) => {
            if (!span) {
                return original.apply(self, args);
            }
            // if unary or clientStream
            if (!original.responseStream) {
                const callbackFuncIndex = utils_1.findIndex(args, arg => {
                    return typeof arg === 'function';
                });
                if (callbackFuncIndex !== -1) {
                    args[callbackFuncIndex] = patchedCallback(span, args[callbackFuncIndex], metadata);
                }
            }
            span.addEvent('sent');
            span.setAttributes({
                [semantic_conventions_1.RpcAttribute.GRPC_METHOD]: original.path,
                [semantic_conventions_1.RpcAttribute.GRPC_KIND]: api_1.SpanKind.CLIENT,
            });
            this._setSpanContext(metadata);
            const call = original.apply(self, args);
            // if server stream or bidi
            if (original.responseStream) {
                // Both error and status events can be emitted
                // the first one emitted set spanEnded to true
                let spanEnded = false;
                const endSpan = () => {
                    if (!spanEnded) {
                        span.end();
                        spanEnded = true;
                    }
                };
                plugin._tracer.bind(call);
                call.on('error', (err) => {
                    span.setStatus({
                        code: utils_1._grpcStatusCodeToCanonicalCode(err.code),
                        message: err.message,
                    });
                    span.setAttributes({
                        [semantic_conventions_1.RpcAttribute.GRPC_ERROR_NAME]: err.name,
                        [semantic_conventions_1.RpcAttribute.GRPC_ERROR_MESSAGE]: err.message,
                    });
                    endSpan();
                });
                call.on('status', (status) => {
                    span.setStatus({ code: api_1.CanonicalCode.OK });
                    span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, status.code.toString());
                    endSpan();
                });
            }
            return call;
        };
    }
    _getMetadata(original, args) {
        let metadata;
        // This finds an instance of Metadata among the arguments.
        // A possible issue that could occur is if the 'options' parameter from
        // the user contains an '_internal_repr' as well as a 'getMap' function,
        // but this is an extremely rare case.
        let metadataIndex = utils_1.findIndex(args, (arg) => {
            return (arg &&
                typeof arg === 'object' &&
                arg._internal_repr &&
                typeof arg.getMap === 'function');
        });
        if (metadataIndex === -1) {
            metadata = new this._moduleExports.Metadata();
            if (!original.requestStream) {
                // unary or server stream
                if (args.length === 0) {
                    // No argument (for the gRPC call) was provided, so we will have to
                    // provide one, since metadata cannot be the first argument.
                    // The internal representation of argument defaults to undefined
                    // in its non-presence.
                    // Note that we can't pass null instead of undefined because the
                    // serializer within gRPC doesn't accept it.
                    args.push(undefined);
                }
                metadataIndex = 1;
            }
            else {
                // client stream or bidi
                metadataIndex = 0;
            }
            args.splice(metadataIndex, 0, metadata);
        }
        else {
            metadata = args[metadataIndex];
        }
        return metadata;
    }
}
exports.GrpcPlugin = GrpcPlugin;
GrpcPlugin.component = 'grpc';
const basedir = path.dirname(require.resolve('grpc'));
const version = require(path.join(basedir, 'package.json')).version;
exports.plugin = new GrpcPlugin(GrpcPlugin.component, version);
//# sourceMappingURL=grpc.js.map