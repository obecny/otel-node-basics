"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientStreamAndUnaryHandler = void 0;
const api_1 = require("@opentelemetry/api");
const utils_1 = require("../utils");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
/**
 * Handle patching for clientStream and unary type server handlers
 */
function clientStreamAndUnaryHandler(plugin, span, call, callback, original) {
    const patchedCallback = (err, value) => {
        if (err) {
            if (err.code) {
                span.setStatus({
                    code: utils_1.grpcStatusCodeToCanonicalCode(err.code),
                    message: err.message,
                });
                span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, err.code.toString());
            }
            span.setAttributes({
                [semantic_conventions_1.RpcAttribute.GRPC_ERROR_NAME]: err.name,
                [semantic_conventions_1.RpcAttribute.GRPC_ERROR_MESSAGE]: err.message,
            });
        }
        else {
            span.setStatus({ code: api_1.CanonicalCode.OK });
            span.setAttribute(semantic_conventions_1.RpcAttribute.GRPC_STATUS_CODE, api_1.CanonicalCode.OK.toString());
        }
        span.end();
        return callback(err, value);
    };
    plugin.tracer.bind(call);
    return original.call({}, call, patchedCallback);
}
exports.clientStreamAndUnaryHandler = clientStreamAndUnaryHandler;
//# sourceMappingURL=clientStreamAndUnary.js.map