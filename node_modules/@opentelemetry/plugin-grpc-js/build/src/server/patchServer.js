"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchServer = void 0;
const shimmer = require("shimmer");
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const clientStreamAndUnary_1 = require("./clientStreamAndUnary");
const serverStreamAndBidi_1 = require("./serverStreamAndBidi");
const utils_1 = require("../utils");
/**
 * Patch for grpc.Server.prototype.register(...) function. Provides auto-instrumentation for
 * client_stream, server_stream, bidi, unary server handler calls.
 */
function patchServer() {
    return (originalRegister) => {
        const plugin = this;
        const config = this._config;
        plugin.logger.debug('patched gRPC server');
        return function register(name, handler, serialize, deserialize, type) {
            const originalRegisterResult = originalRegister.call(this, name, handler, serialize, deserialize, type);
            const handlerSet = this['handlers'].get(name);
            shimmer.wrap(handlerSet, 'func', (originalFunc) => {
                return function func(call, callback) {
                    const self = this;
                    if (shouldNotTraceServerCall(call.metadata, name, config.ignoreGrpcMethods)) {
                        return handleUntracedServerFunction(type, originalFunc, call, callback);
                    }
                    const spanName = `grpc.${name.replace('/', '')}`;
                    const spanOptions = {
                        kind: api_1.SpanKind.SERVER,
                    };
                    plugin.logger.debug('patch func: %s', JSON.stringify(spanOptions));
                    api_1.context.with(api_1.propagation.extract(call.metadata, (carrier, key) => carrier.get(key)), () => {
                        const span = plugin.tracer
                            .startSpan(spanName, spanOptions)
                            .setAttributes({
                            [semantic_conventions_1.RpcAttribute.GRPC_KIND]: spanOptions.kind,
                        });
                        plugin.tracer.withSpan(span, () => {
                            handleServerFunction.call(self, plugin, span, type, originalFunc, call, callback);
                        });
                    });
                };
            });
            return originalRegisterResult;
        };
    };
}
exports.patchServer = patchServer;
/**
 * Returns true if the server call should not be traced.
 */
function shouldNotTraceServerCall(metadata, methodName, ignoreGrpcMethods) {
    const parsedName = methodName.split('/');
    return (utils_1.containsOtelMetadata(metadata) ||
        utils_1.methodIsIgnored(parsedName[parsedName.length - 1] || methodName, ignoreGrpcMethods));
}
/**
 * Patch callback or EventEmitter provided by `originalFunc` and set appropriate `span`
 * properties based on its result.
 */
function handleServerFunction(plugin, span, type, originalFunc, call, callback) {
    switch (type) {
        case 'unary':
        case 'clientStream':
        case 'client_stream':
            return clientStreamAndUnary_1.clientStreamAndUnaryHandler(plugin, span, call, callback, originalFunc);
        case 'serverStream':
        case 'server_stream':
        case 'bidi':
            return serverStreamAndBidi_1.serverStreamAndBidiHandler(plugin, span, call, originalFunc);
        default:
            break;
    }
}
/**
 * Does not patch any callbacks or EventEmitters to omit tracing on requests
 * that should not be traced.
 */
function handleUntracedServerFunction(type, originalFunc, call, callback) {
    switch (type) {
        case 'unary':
        case 'clientStream':
        case 'client_stream':
            return originalFunc.call({}, call, callback);
        case 'serverStream':
        case 'server_stream':
        case 'bidi':
            return originalFunc.call({}, call);
        default:
            break;
    }
}
//# sourceMappingURL=patchServer.js.map