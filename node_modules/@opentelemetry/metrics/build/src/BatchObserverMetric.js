"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchObserverMetric = void 0;
const BatchObserverResult_1 = require("./BatchObserverResult");
const BoundInstrument_1 = require("./BoundInstrument");
const types_1 = require("./export/types");
const Metric_1 = require("./Metric");
const NOOP_CALLBACK = () => { };
const MAX_TIMEOUT_UPDATE_MS = 500;
/** This is a SDK implementation of Batch Observer Metric. */
class BatchObserverMetric extends Metric_1.Metric {
    constructor(name, options, _batcher, resource, instrumentationLibrary, callback) {
        var _a;
        super(name, options, types_1.MetricKind.VALUE_OBSERVER, resource, instrumentationLibrary);
        this._batcher = _batcher;
        this._maxTimeoutUpdateMS = (_a = options.maxTimeoutUpdateMS) !== null && _a !== void 0 ? _a : MAX_TIMEOUT_UPDATE_MS;
        this._callback = callback || NOOP_CALLBACK;
    }
    _makeInstrument(labels) {
        return new BoundInstrument_1.BoundObserver(labels, this._disabled, this._valueType, this._logger, this._batcher.aggregatorFor(this._descriptor));
    }
    getMetricRecord() {
        this._logger.debug('getMetricRecord - start');
        return new Promise((resolve, reject) => {
            const observerResult = new BatchObserverResult_1.BatchObserverResult();
            // cancels after MAX_TIMEOUT_MS - no more waiting for results
            const timer = setTimeout(() => {
                observerResult.cancelled = true;
                // remove callback to prevent user from updating the values later if
                // for any reason the observerBatchResult will be referenced
                observerResult.onObserveCalled();
                super.getMetricRecord().then(resolve, reject);
                this._logger.debug('getMetricRecord - timeout');
            }, this._maxTimeoutUpdateMS);
            // sets callback for each "observe" method
            observerResult.onObserveCalled(() => {
                clearTimeout(timer);
                super.getMetricRecord().then(resolve, reject);
                this._logger.debug('getMetricRecord - end');
            });
            // calls the BatchObserverResult callback
            this._callback(observerResult);
        });
    }
}
exports.BatchObserverMetric = BatchObserverMetric;
//# sourceMappingURL=BatchObserverMetric.js.map