"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupMetricsByResourceAndLibrary = exports.toCollectorExportMetricServiceRequest = exports.toCollectorMetric = exports.toSummaryPoint = exports.toHistogramPoint = exports.toSingularPoint = exports.toCollectorMetricDescriptor = exports.toCollectorTemporality = exports.toCollectorType = exports.toCollectorLabels = void 0;
const metrics_1 = require("@opentelemetry/metrics");
const types_1 = require("./types");
const api = require("@opentelemetry/api");
const core = require("@opentelemetry/core");
const transform_1 = require("./transform");
/**
 * Converts labels
 * @param labels
 */
function toCollectorLabels(labels) {
    return Object.entries(labels).map(([key, value]) => {
        return { key, value: String(value) };
    });
}
exports.toCollectorLabels = toCollectorLabels;
/**
 * Given a MetricDescriptor, return its type in a compatible format with the collector
 * @param descriptor
 */
function toCollectorType(metric) {
    if (metric.descriptor.metricKind === metrics_1.MetricKind.COUNTER ||
        metric.descriptor.metricKind === metrics_1.MetricKind.SUM_OBSERVER) {
        if (metric.descriptor.valueType === api.ValueType.INT) {
            return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.MONOTONIC_INT64;
        }
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.MONOTONIC_DOUBLE;
    }
    if (metric.aggregator instanceof metrics_1.HistogramAggregator) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.HISTOGRAM;
    }
    if (metric.aggregator instanceof metrics_1.MinMaxLastSumCountAggregator) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.SUMMARY;
    }
    if (metric.descriptor.valueType == api.ValueType.INT) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.INT64;
    }
    if (metric.descriptor.valueType === api.ValueType.DOUBLE) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.DOUBLE;
    }
    return types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.INVALID_TYPE;
}
exports.toCollectorType = toCollectorType;
/**
 * Given a MetricDescriptor, return its temporality in a compatible format with the collector
 * @param descriptor
 */
function toCollectorTemporality(metric) {
    if (metric.descriptor.metricKind === metrics_1.MetricKind.COUNTER ||
        metric.descriptor.metricKind === metrics_1.MetricKind.SUM_OBSERVER) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorTemporality.CUMULATIVE;
    }
    if (metric.descriptor.metricKind === metrics_1.MetricKind.UP_DOWN_COUNTER ||
        metric.descriptor.metricKind === metrics_1.MetricKind.UP_DOWN_SUM_OBSERVER) {
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorTemporality.DELTA;
    }
    if (metric.descriptor.metricKind === metrics_1.MetricKind.VALUE_OBSERVER ||
        metric.descriptor.metricKind === metrics_1.MetricKind.VALUE_RECORDER) {
        // TODO: Change once LastValueAggregator is implemented.
        // If the aggregator is LastValue or Exact, then it will be instantaneous
        return types_1.opentelemetryProto.metrics.v1.MetricDescriptorTemporality.DELTA;
    }
    return types_1.opentelemetryProto.metrics.v1.MetricDescriptorTemporality
        .INVALID_TEMPORALITY;
}
exports.toCollectorTemporality = toCollectorTemporality;
/**
 * Given a MetricRecord, return the Collector compatible type of MetricDescriptor
 * @param metric
 */
function toCollectorMetricDescriptor(metric) {
    return {
        name: metric.descriptor.name,
        description: metric.descriptor.description,
        unit: metric.descriptor.unit,
        type: toCollectorType(metric),
        temporality: toCollectorTemporality(metric),
    };
}
exports.toCollectorMetricDescriptor = toCollectorMetricDescriptor;
/**
 * Returns an Int64Point or DoublePoint to the collector
 * @param metric
 * @param startTime
 */
function toSingularPoint(metric, startTime) {
    return {
        labels: toCollectorLabels(metric.labels),
        value: metric.aggregator.toPoint().value,
        startTimeUnixNano: startTime,
        timeUnixNano: core.hrTimeToNanoseconds(metric.aggregator.toPoint().timestamp),
    };
}
exports.toSingularPoint = toSingularPoint;
/**
 * Returns a HistogramPoint to the collector
 * @param metric
 * @param startTime
 */
function toHistogramPoint(metric, startTime) {
    const { value, timestamp } = metric.aggregator.toPoint();
    return {
        labels: toCollectorLabels(metric.labels),
        sum: value.sum,
        count: value.count,
        startTimeUnixNano: startTime,
        timeUnixNano: core.hrTimeToNanoseconds(timestamp),
        buckets: value.buckets.counts.map(count => {
            return { count };
        }),
        explicitBounds: value.buckets.boundaries,
    };
}
exports.toHistogramPoint = toHistogramPoint;
/**
 * Returns a SummaryPoint to the collector
 * @param metric
 * @param startTime
 */
function toSummaryPoint(metric, startTime) {
    const { value, timestamp } = metric.aggregator.toPoint();
    return {
        labels: toCollectorLabels(metric.labels),
        sum: value.sum,
        count: value.count,
        startTimeUnixNano: startTime,
        timeUnixNano: core.hrTimeToNanoseconds(timestamp),
        percentileValues: [
            { percentile: 0, value: value.min },
            { percentile: 100, value: value.max },
        ],
    };
}
exports.toSummaryPoint = toSummaryPoint;
/**
 * Converts a metric to be compatible with the collector
 * @param metric
 * @param startTime start time in nanoseconds
 */
function toCollectorMetric(metric, startTime) {
    if (toCollectorType(metric) ===
        types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.HISTOGRAM) {
        return {
            metricDescriptor: toCollectorMetricDescriptor(metric),
            histogramDataPoints: [toHistogramPoint(metric, startTime)],
        };
    }
    if (toCollectorType(metric) ===
        types_1.opentelemetryProto.metrics.v1.MetricDescriptorType.SUMMARY) {
        return {
            metricDescriptor: toCollectorMetricDescriptor(metric),
            summaryDataPoints: [toSummaryPoint(metric, startTime)],
        };
    }
    if (metric.descriptor.valueType == api.ValueType.INT) {
        return {
            metricDescriptor: toCollectorMetricDescriptor(metric),
            int64DataPoints: [toSingularPoint(metric, startTime)],
        };
    }
    if (metric.descriptor.valueType === api.ValueType.DOUBLE) {
        return {
            metricDescriptor: toCollectorMetricDescriptor(metric),
            doubleDataPoints: [toSingularPoint(metric, startTime)],
        };
    }
    return {
        metricDescriptor: toCollectorMetricDescriptor(metric),
        int64DataPoints: [],
    };
}
exports.toCollectorMetric = toCollectorMetric;
/**
 * Prepares metric service request to be sent to collector
 * @param metrics metrics
 * @param startTime start time of the metric in nanoseconds
 * @param collectorMetricExporterBase
 */
function toCollectorExportMetricServiceRequest(metrics, startTime, collectorExporterBase) {
    const groupedMetrics = groupMetricsByResourceAndLibrary(metrics);
    const additionalAttributes = Object.assign({}, collectorExporterBase.attributes, {
        'service.name': collectorExporterBase.serviceName,
    });
    return {
        resourceMetrics: toCollectorResourceMetrics(groupedMetrics, additionalAttributes, startTime),
    };
}
exports.toCollectorExportMetricServiceRequest = toCollectorExportMetricServiceRequest;
/**
 * Takes an array of metrics and groups them by resource and instrumentation
 * library
 * @param metrics metrics
 */
function groupMetricsByResourceAndLibrary(metrics) {
    return metrics.reduce((metricMap, metric) => {
        //group by resource
        let resourceMetrics = metricMap.get(metric.resource);
        if (!resourceMetrics) {
            resourceMetrics = new Map();
            metricMap.set(metric.resource, resourceMetrics);
        }
        //group by instrumentation library
        let libMetrics = resourceMetrics.get(metric.instrumentationLibrary);
        if (!libMetrics) {
            libMetrics = new Array();
            resourceMetrics.set(metric.instrumentationLibrary, libMetrics);
        }
        libMetrics.push(metric);
        return metricMap;
    }, new Map());
}
exports.groupMetricsByResourceAndLibrary = groupMetricsByResourceAndLibrary;
/**
 * Convert to InstrumentationLibraryMetrics
 * @param instrumentationLibrary
 * @param metrics
 * @param startTime
 */
function toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime) {
    return {
        metrics: metrics.map(metric => toCollectorMetric(metric, startTime)),
        instrumentationLibrary,
    };
}
/**
 * Returns a list of resource metrics which will be exported to the collector
 * @param groupedSpans
 * @param baseAttributes
 */
function toCollectorResourceMetrics(groupedMetrics, baseAttributes, startTime) {
    return Array.from(groupedMetrics, ([resource, libMetrics]) => {
        return {
            resource: transform_1.toCollectorResource(resource, baseAttributes),
            instrumentationLibraryMetrics: Array.from(libMetrics, ([instrumentationLibrary, metrics]) => toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime)),
        };
    });
}
//# sourceMappingURL=transformMetrics.js.map