"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.COLLECTOR_SPAN_KIND_MAPPING = exports.opentelemetryProto = exports.OT_REQUEST_HEADER = void 0;
const api_1 = require("@opentelemetry/api");
// header to prevent instrumentation on request
exports.OT_REQUEST_HEADER = 'x-opentelemetry-outgoing-request';
/* eslint-disable @typescript-eslint/no-namespace */
var opentelemetryProto;
(function (opentelemetryProto) {
    let metrics;
    (function (metrics) {
        let v1;
        (function (v1) {
            let MetricDescriptorType;
            (function (MetricDescriptorType) {
                MetricDescriptorType[MetricDescriptorType["INVALID_TYPE"] = 0] = "INVALID_TYPE";
                MetricDescriptorType[MetricDescriptorType["INT64"] = 1] = "INT64";
                MetricDescriptorType[MetricDescriptorType["MONOTONIC_INT64"] = 2] = "MONOTONIC_INT64";
                MetricDescriptorType[MetricDescriptorType["DOUBLE"] = 3] = "DOUBLE";
                MetricDescriptorType[MetricDescriptorType["MONOTONIC_DOUBLE"] = 4] = "MONOTONIC_DOUBLE";
                MetricDescriptorType[MetricDescriptorType["HISTOGRAM"] = 5] = "HISTOGRAM";
                MetricDescriptorType[MetricDescriptorType["SUMMARY"] = 6] = "SUMMARY";
            })(MetricDescriptorType = v1.MetricDescriptorType || (v1.MetricDescriptorType = {}));
            let MetricDescriptorTemporality;
            (function (MetricDescriptorTemporality) {
                MetricDescriptorTemporality[MetricDescriptorTemporality["INVALID_TEMPORALITY"] = 0] = "INVALID_TEMPORALITY";
                MetricDescriptorTemporality[MetricDescriptorTemporality["INSTANTANEOUS"] = 1] = "INSTANTANEOUS";
                MetricDescriptorTemporality[MetricDescriptorTemporality["DELTA"] = 2] = "DELTA";
                MetricDescriptorTemporality[MetricDescriptorTemporality["CUMULATIVE"] = 3] = "CUMULATIVE";
            })(MetricDescriptorTemporality = v1.MetricDescriptorTemporality || (v1.MetricDescriptorTemporality = {}));
        })(v1 = metrics.v1 || (metrics.v1 = {}));
    })(metrics = opentelemetryProto.metrics || (opentelemetryProto.metrics = {}));
    let trace;
    (function (trace) {
        let v1;
        (function (v1) {
            let ConstantSampler;
            (function (ConstantSampler) {
                let ConstantDecision;
                (function (ConstantDecision) {
                    ConstantDecision[ConstantDecision["ALWAYS_OFF"] = 0] = "ALWAYS_OFF";
                    ConstantDecision[ConstantDecision["ALWAYS_ON"] = 1] = "ALWAYS_ON";
                    ConstantDecision[ConstantDecision["ALWAYS_PARENT"] = 2] = "ALWAYS_PARENT";
                })(ConstantDecision = ConstantSampler.ConstantDecision || (ConstantSampler.ConstantDecision = {}));
            })(ConstantSampler = v1.ConstantSampler || (v1.ConstantSampler = {}));
            let Span;
            (function (Span) {
                let SpanKind;
                (function (SpanKind) {
                    SpanKind[SpanKind["SPAN_KIND_UNSPECIFIED"] = 0] = "SPAN_KIND_UNSPECIFIED";
                    SpanKind[SpanKind["INTERNAL"] = 1] = "INTERNAL";
                    SpanKind[SpanKind["SERVER"] = 2] = "SERVER";
                    SpanKind[SpanKind["CLIENT"] = 3] = "CLIENT";
                    SpanKind[SpanKind["PRODUCER"] = 4] = "PRODUCER";
                    SpanKind[SpanKind["CONSUMER"] = 5] = "CONSUMER";
                })(SpanKind = Span.SpanKind || (Span.SpanKind = {}));
            })(Span = v1.Span || (v1.Span = {}));
        })(v1 = trace.v1 || (trace.v1 = {}));
    })(trace = opentelemetryProto.trace || (opentelemetryProto.trace = {}));
    let common;
    (function (common) {
        let v1;
        (function (v1) {
            let ValueType;
            (function (ValueType) {
                ValueType[ValueType["STRING"] = 0] = "STRING";
                ValueType[ValueType["INT"] = 1] = "INT";
                ValueType[ValueType["DOUBLE"] = 2] = "DOUBLE";
                ValueType[ValueType["BOOL"] = 3] = "BOOL";
            })(ValueType = v1.ValueType || (v1.ValueType = {}));
        })(v1 = common.v1 || (common.v1 = {}));
    })(common = opentelemetryProto.common || (opentelemetryProto.common = {}));
})(opentelemetryProto = exports.opentelemetryProto || (exports.opentelemetryProto = {}));
/**
 * Mapping between api SpanKind and proto SpanKind
 */
exports.COLLECTOR_SPAN_KIND_MAPPING = {
    [api_1.SpanKind.INTERNAL]: opentelemetryProto.trace.v1.Span.SpanKind.INTERNAL,
    [api_1.SpanKind.SERVER]: opentelemetryProto.trace.v1.Span.SpanKind.SERVER,
    [api_1.SpanKind.CLIENT]: opentelemetryProto.trace.v1.Span.SpanKind.CLIENT,
    [api_1.SpanKind.PRODUCER]: opentelemetryProto.trace.v1.Span.SpanKind.PRODUCER,
    [api_1.SpanKind.CONSUMER]: opentelemetryProto.trace.v1.Span.SpanKind.CONSUMER,
};
//# sourceMappingURL=types.js.map