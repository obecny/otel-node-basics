"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectorExporterBase = void 0;
const core_1 = require("@opentelemetry/core");
/**
 * Collector Exporter abstract base class
 */
class CollectorExporterBase {
    /**
     * @param config
     */
    constructor(config = {}) {
        this._isShutdown = false;
        this.serviceName = this.getDefaultServiceName(config);
        this.url = this.getDefaultUrl(config);
        if (typeof config.hostname === 'string') {
            this.hostname = config.hostname;
        }
        this.attributes = config.attributes;
        this.logger = config.logger || new core_1.NoopLogger();
        this.shutdown = this.shutdown.bind(this);
        // platform dependent
        this.onInit(config);
    }
    /**
     * Export items.
     * @param items
     * @param resultCallback
     */
    export(items, resultCallback) {
        if (this._isShutdown) {
            resultCallback(core_1.ExportResult.FAILED_NOT_RETRYABLE);
            return;
        }
        this._export(items)
            .then(() => {
            resultCallback(core_1.ExportResult.SUCCESS);
        })
            .catch((error) => {
            if (error.message) {
                this.logger.error(error.message);
            }
            if (error.code && error.code < 500) {
                resultCallback(core_1.ExportResult.FAILED_NOT_RETRYABLE);
            }
            else {
                resultCallback(core_1.ExportResult.FAILED_RETRYABLE);
            }
        });
    }
    _export(items) {
        return new Promise((resolve, reject) => {
            try {
                this.logger.debug('items to be sent', items);
                this.send(items, resolve, reject);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Shutdown the exporter.
     */
    shutdown() {
        if (this._isShutdown) {
            this.logger.debug('shutdown already started');
            return;
        }
        this._isShutdown = true;
        this.logger.debug('shutdown started');
        // platform dependent
        this.onShutdown();
    }
}
exports.CollectorExporterBase = CollectorExporterBase;
//# sourceMappingURL=CollectorExporterBase.js.map