import { SpanKind, Logger, Attributes } from '@opentelemetry/api';
import * as api from '@opentelemetry/api';
export declare const OT_REQUEST_HEADER = "x-opentelemetry-outgoing-request";
export declare namespace opentelemetryProto {
    namespace collector {
        namespace trace.v1 {
            interface TraceService {
                service: opentelemetryProto.collector.trace.v1.TraceService;
            }
            interface ExportTraceServiceRequest {
                resourceSpans: opentelemetryProto.trace.v1.ResourceSpans[];
            }
        }
        namespace metrics.v1 {
            interface ExportMetricsServiceRequest {
                resourceMetrics: opentelemetryProto.metrics.v1.ResourceMetrics[];
            }
        }
    }
    namespace resource.v1 {
        interface Resource {
            attributes: opentelemetryProto.common.v1.KeyValue[];
            droppedAttributesCount: number;
        }
    }
    namespace metrics.v1 {
        interface Metric {
            metricDescriptor: opentelemetryProto.metrics.v1.MetricDescriptor;
            int64DataPoints?: opentelemetryProto.metrics.v1.Int64DataPoint[];
            doubleDataPoints?: opentelemetryProto.metrics.v1.DoubleDataPoint[];
            histogramDataPoints?: opentelemetryProto.metrics.v1.HistogramDataPoint[];
            summaryDataPoints?: opentelemetryProto.metrics.v1.SummaryDataPoint[];
        }
        interface Int64DataPoint {
            labels: opentelemetryProto.common.v1.StringKeyValue[];
            startTimeUnixNano: number;
            timeUnixNano: number;
            value: number;
        }
        interface DoubleDataPoint {
            labels: opentelemetryProto.common.v1.StringKeyValue[];
            startTimeUnixNano: number;
            timeUnixNano: number;
            value: number;
        }
        interface HistogramDataPoint {
            labels: opentelemetryProto.common.v1.StringKeyValue[];
            startTimeUnixNano: number;
            timeUnixNano: number;
            count: number;
            sum: number;
            buckets?: opentelemetryProto.metrics.v1.HistogramDataPointBucket[];
            explicitBounds?: number[];
        }
        interface HistogramDataPointBucket {
            count: number;
            exemplar?: opentelemetryProto.metrics.v1.HistogramExemplar;
        }
        interface HistogramExemplar {
            value: number;
            timeUnixNano: number;
            attachments: opentelemetryProto.common.v1.StringKeyValue[];
        }
        interface SummaryDataPoint {
            labels: opentelemetryProto.common.v1.StringKeyValue[];
            startTimeUnixNano: number;
            timeUnixNano: number;
            count?: number;
            sum?: number;
            percentileValues: opentelemetryProto.metrics.v1.SummaryDataPointValueAtPercentile[];
        }
        interface SummaryDataPointValueAtPercentile {
            percentile: number;
            value: number;
        }
        interface MetricDescriptor {
            name: string;
            description: string;
            unit: string;
            type: opentelemetryProto.metrics.v1.MetricDescriptorType;
            temporality: opentelemetryProto.metrics.v1.MetricDescriptorTemporality;
        }
        interface InstrumentationLibraryMetrics {
            instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;
            metrics: opentelemetryProto.metrics.v1.Metric[];
        }
        interface ResourceMetrics {
            resource?: opentelemetryProto.resource.v1.Resource;
            instrumentationLibraryMetrics: opentelemetryProto.metrics.v1.InstrumentationLibraryMetrics[];
        }
        enum MetricDescriptorType {
            INVALID_TYPE = 0,
            INT64 = 1,
            MONOTONIC_INT64 = 2,
            DOUBLE = 3,
            MONOTONIC_DOUBLE = 4,
            HISTOGRAM = 5,
            SUMMARY = 6
        }
        enum MetricDescriptorTemporality {
            INVALID_TEMPORALITY = 0,
            INSTANTANEOUS = 1,
            DELTA = 2,
            CUMULATIVE = 3
        }
    }
    namespace trace.v1 {
        namespace ConstantSampler {
            enum ConstantDecision {
                ALWAYS_OFF = 0,
                ALWAYS_ON = 1,
                ALWAYS_PARENT = 2
            }
        }
        namespace Span {
            interface Event {
                timeUnixNano: number;
                name: string;
                attributes?: opentelemetryProto.common.v1.KeyValue[];
                droppedAttributesCount: number;
            }
            interface Link {
                traceId: string;
                spanId: string;
                traceState?: opentelemetryProto.trace.v1.Span.TraceState;
                attributes?: opentelemetryProto.common.v1.KeyValue[];
                droppedAttributesCount: number;
            }
            enum SpanKind {
                SPAN_KIND_UNSPECIFIED = 0,
                INTERNAL = 1,
                SERVER = 2,
                CLIENT = 3,
                PRODUCER = 4,
                CONSUMER = 5
            }
            type TraceState = string | undefined;
        }
        interface ConstantSampler {
            decision?: opentelemetryProto.trace.v1.ConstantSampler.ConstantDecision;
        }
        interface InstrumentationLibrarySpans {
            instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;
            spans: opentelemetryProto.trace.v1.Span[];
        }
        interface ProbabilitySampler {
            samplingProbability?: number | null;
        }
        interface RateLimitingSampler {
            qps?: number | null;
        }
        interface ResourceSpans {
            resource?: opentelemetryProto.resource.v1.Resource;
            instrumentationLibrarySpans: opentelemetryProto.trace.v1.InstrumentationLibrarySpans[];
        }
        interface Span {
            traceId: string;
            spanId: string;
            traceState: opentelemetryProto.trace.v1.Span.TraceState;
            parentSpanId?: string;
            name?: string;
            kind?: opentelemetryProto.trace.v1.Span.SpanKind;
            startTimeUnixNano?: number;
            endTimeUnixNano?: number;
            attributes?: opentelemetryProto.common.v1.KeyValue[];
            droppedAttributesCount: number;
            events?: opentelemetryProto.trace.v1.Span.Event[];
            droppedEventsCount: number;
            links?: opentelemetryProto.trace.v1.Span.Link[];
            droppedLinksCount: number;
            status?: Status;
        }
        type Status = api.Status;
        interface TraceConfig {
            constantSampler?: ConstantSampler | null;
            probabilitySampler?: ProbabilitySampler | null;
            rateLimitingSampler?: RateLimitingSampler | null;
        }
    }
    namespace common.v1 {
        interface KeyValue {
            key: string;
            value: AnyValue;
        }
        type ArrayValue = {
            values: AnyValue[];
        };
        interface KeyValueList {
            values: KeyValue[];
        }
        type AnyValue = {
            stringValue?: string;
            boolValue?: boolean;
            intValue?: number;
            doubleValue?: number;
            arrayValue?: ArrayValue;
            kvlistValue?: KeyValueList;
        };
        interface InstrumentationLibrary {
            name: string;
            version: string;
        }
        interface StringKeyValue {
            key: string;
            value: string;
        }
        enum ValueType {
            STRING = 0,
            INT = 1,
            DOUBLE = 2,
            BOOL = 3
        }
    }
}
/**
 * Interface for handling error
 */
export interface CollectorExporterError {
    code?: number;
    message?: string;
    stack?: string;
}
/**
 * Interface for handling export service errors
 */
export interface ExportServiceError {
    code: number;
    details: string;
    metadata: {
        [key: string]: unknown;
    };
    message: string;
    stack: string;
}
/**
 * Collector Exporter base config
 */
export interface CollectorExporterConfigBase {
    headers?: Partial<Record<string, unknown>>;
    hostname?: string;
    logger?: Logger;
    serviceName?: string;
    attributes?: Attributes;
    url?: string;
}
/**
 * Mapping between api SpanKind and proto SpanKind
 */
export declare const COLLECTOR_SPAN_KIND_MAPPING: {
    0: opentelemetryProto.trace.v1.Span.SpanKind;
    1: opentelemetryProto.trace.v1.Span.SpanKind;
    2: opentelemetryProto.trace.v1.Span.SpanKind;
    3: opentelemetryProto.trace.v1.Span.SpanKind;
    4: opentelemetryProto.trace.v1.Span.SpanKind;
};
//# sourceMappingURL=types.d.ts.map